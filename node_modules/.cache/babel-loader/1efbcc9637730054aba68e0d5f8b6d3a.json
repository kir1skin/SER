{"ast":null,"code":"class Queue {\n  constructor() {\n    this.order = [];\n    this.scheduled = new Set();\n  }\n\n  add(process) {\n    if (!this.scheduled.has(process)) {\n      this.scheduled.add(process);\n      this.order.push(process);\n      return true;\n    }\n  }\n\n  remove(process) {\n    const index = this.order.indexOf(process);\n\n    if (index !== -1) {\n      this.order.splice(index, 1);\n      this.scheduled.delete(process);\n    }\n  }\n\n  clear() {\n    this.order.length = 0;\n    this.scheduled.clear();\n  }\n\n}\n\nfunction createRenderStep(runNextFrame) {\n  /**\n   * We create and reuse two queues, one to queue jobs for the current frame\n   * and one for the next. We reuse to avoid triggering GC after x frames.\n   */\n  let thisFrame = new Queue();\n  let nextFrame = new Queue();\n  let numToRun = 0;\n  /**\n   * Track whether we're currently processing jobs in this step. This way\n   * we can decide whether to schedule new jobs for this frame or next.\n   */\n\n  let isProcessing = false;\n  let flushNextFrame = false;\n  /**\n   * A set of processes which were marked keepAlive when scheduled.\n   */\n\n  const toKeepAlive = new WeakSet();\n  const step = {\n    /**\n     * Schedule a process to run on the next frame.\n     */\n    schedule: function (callback) {\n      let keepAlive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      let immediate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      const addToCurrentFrame = immediate && isProcessing;\n      const queue = addToCurrentFrame ? thisFrame : nextFrame;\n      if (keepAlive) toKeepAlive.add(callback);\n\n      if (queue.add(callback) && addToCurrentFrame && isProcessing) {\n        // If we're adding it to the currently running queue, update its measured size\n        numToRun = thisFrame.order.length;\n      }\n\n      return callback;\n    },\n\n    /**\n     * Cancel the provided callback from running on the next frame.\n     */\n    cancel: callback => {\n      nextFrame.remove(callback);\n      toKeepAlive.delete(callback);\n    },\n\n    /**\n     * Execute all schedule callbacks.\n     */\n    process: frameData => {\n      /**\n       * If we're already processing we've probably been triggered by a flushSync\n       * inside an existing process. Instead of executing, mark flushNextFrame\n       * as true and ensure we flush the following frame at the end of this one.\n       */\n      if (isProcessing) {\n        flushNextFrame = true;\n        return;\n      }\n\n      isProcessing = true;\n      [thisFrame, nextFrame] = [nextFrame, thisFrame]; // Clear the next frame queue\n\n      nextFrame.clear(); // Execute this frame\n\n      numToRun = thisFrame.order.length;\n\n      if (numToRun) {\n        for (let i = 0; i < numToRun; i++) {\n          const callback = thisFrame.order[i];\n\n          if (toKeepAlive.has(callback)) {\n            step.schedule(callback);\n            runNextFrame();\n          }\n\n          callback(frameData);\n        }\n      }\n\n      isProcessing = false;\n\n      if (flushNextFrame) {\n        flushNextFrame = false;\n        step.process(frameData);\n      }\n    }\n  };\n  return step;\n}\n\nexport { createRenderStep };","map":null,"metadata":{},"sourceType":"module"}