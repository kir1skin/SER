{"ast":null,"code":"import _taggedTemplateLiteral from\"C:/Users/User.DESKTOP-703GDSJ.000/Desktop/tapswapbotcodecomplete/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js\";var _templateObject,_templateObject2,_templateObject3;import React,{useState,useEffect,useRef}from'react';import{doc,updateDoc}from'firebase/firestore';import{db}from'../firebase';// Adjust the path as needed\nimport styled,{keyframes}from\"styled-components\";import{MdOutlineKeyboardArrowRight}from\"react-icons/md\";import Animate from'../Components/Animate';import Spinner from'../Components/Spinner';import{useUser}from'../context/userContext';import Levels from'../Components/Levels';import flash from\"../images/flash.webp\";import coinsmall from\"../images/coinsmall.webp\";import{jsx as _jsx}from\"react/jsx-runtime\";import{jsxs as _jsxs}from\"react/jsx-runtime\";import{Fragment as _Fragment}from\"react/jsx-runtime\";const slideUp=keyframes(_templateObject||(_templateObject=_taggedTemplateLiteral([\"\\n  0% {\\n    opacity: 1;\\n    transform: translateY(0);\\n  }\\n  100% {\\n    opacity: 0;\\n    transform: translateY(-350px);\\n  }\\n\"])));const SlideUpText=styled.div(_templateObject2||(_templateObject2=_taggedTemplateLiteral([\"\\n  position: absolute;\\n  animation: \",\" 3s ease-out;\\n  font-size: 2.1em;\\n  color: #ffffffa6;\\n  font-weight: 600;\\n  left: \",\"px;\\n  top: \",\"px;\\n  pointer-events: none; /* To prevent any interaction */\\n\"])),slideUp,_ref=>{let{x}=_ref;return x;},_ref2=>{let{y}=_ref2;return y;});const Container=styled.div(_templateObject3||(_templateObject3=_taggedTemplateLiteral([\"\\n  position: relative;\\n  display: inline-block;\\n  text-align: center;\\n  width: 100%;\\n  height: 100%;\\n\"])));const Plutos=()=>{const imageRef=useRef(null);const[clicks,setClicks]=useState([]);const{balance,tapBalance,energy,battery,tapGuru,mainTap,setIsRefilling,refillIntervalRef,refillEnergy,setEnergy,tapValue,setTapBalance,setBalance,refBonus,level,loading}=useUser();// eslint-disable-next-line\nconst[points,setPoints]=useState(0);// eslint-disable-next-line\nconst[isDisabled,setIsDisabled]=useState(false);// eslint-disable-next-line\nconst[openClaim,setOpenClaim]=useState(false);// eslint-disable-next-line\nconst[congrats,setCongrats]=useState(false);// eslint-disable-next-line\nconst[glowBooster,setGlowBooster]=useState(false);const[showLevels,setShowLevels]=useState(false);const debounceTimerRef=useRef(null);// eslint-disable-next-line\nconst refillTimerRef=useRef(null);const isUpdatingRef=useRef(false);const accumulatedBalanceRef=useRef(balance);const accumulatedEnergyRef=useRef(energy);const accumulatedTapBalanceRef=useRef(tapBalance);const refillTimeoutRef=useRef(null);// Add this line\nfunction triggerHapticFeedback(){const isAndroid=/Android/i.test(navigator.userAgent);const isIOS=/iPhone|iPad|iPod/i.test(navigator.userAgent);if(isIOS&&window.Telegram&&window.Telegram.WebApp&&window.Telegram.WebApp.HapticFeedback){window.Telegram.WebApp.HapticFeedback.impactOccurred('medium');}else if(isAndroid&&'vibrate'in navigator){// Use the vibration API on Android\nnavigator.vibrate(50);// Vibrate for 50ms\n}else{console.warn('Haptic feedback not supported on this device.');}}const handleClick=e=>{triggerHapticFeedback();if(energy<=0||isDisabled||isUpdatingRef.current){setGlowBooster(true);// Trigger glow effect if energy and points are 0\nsetTimeout(()=>{setGlowBooster(false);// Remove glow effect after 1 second\n},300);return;// Exit if no energy left or if clicks are disabled or if an update is in progress\n}const{offsetX,offsetY,target}=e.nativeEvent;const{clientWidth,clientHeight}=target;const horizontalMidpoint=clientWidth/2;const verticalMidpoint=clientHeight/2;const animationClass=offsetX<horizontalMidpoint?'wobble-left':offsetX>horizontalMidpoint?'wobble-right':offsetY<verticalMidpoint?'wobble-top':'wobble-bottom';// Remove previous animations\nimageRef.current.classList.remove('wobble-top','wobble-bottom','wobble-left','wobble-right');// Add the new animation class\nimageRef.current.classList.add(animationClass);// Remove the animation class after animation ends to allow re-animation on the same side\nsetTimeout(()=>{imageRef.current.classList.remove(animationClass);},500);// duration should match the animation duration in CSS\n// Increment the count\nconst rect=e.target.getBoundingClientRect();const newClick={id:Date.now(),// Unique identifier\nx:e.clientX-rect.left,y:e.clientY-rect.top};setClicks(prevClicks=>[...prevClicks,newClick]);// Update state immediately for UI\nsetEnergy(prevEnergy=>{const newEnergy=Math.max(prevEnergy-tapValue.value,0);// Ensure energy does not drop below zero\naccumulatedEnergyRef.current=newEnergy;return newEnergy;});setPoints(prevPoints=>prevPoints+tapValue.value);setBalance(prevBalance=>{const newBalance=prevBalance+tapValue.value;accumulatedBalanceRef.current=newBalance;return newBalance;});setTapBalance(prevTapBalance=>{const newTapBalance=prevTapBalance+tapValue.value;accumulatedTapBalanceRef.current=newTapBalance;return newTapBalance;});// Remove the click after the animation duration\nsetTimeout(()=>{setClicks(prevClicks=>prevClicks.filter(click=>click.id!==newClick.id));},1000);// Match this duration with the animation duration\n// Reset the debounce timer\nclearTimeout(debounceTimerRef.current);debounceTimerRef.current=setTimeout(updateFirestore,1000);// Adjust the delay as needed\n// Reset the refill timer\nclearInterval(refillIntervalRef.current);// Stop refilling while the user is active\nsetIsRefilling(false);// Set refilling state to false\nclearTimeout(refillTimeoutRef.current);refillTimeoutRef.current=setTimeout(()=>{if(energy<battery.energy){refillEnergy();}},1000);// Set the inactivity period to 3 seconds (adjust as needed)\n};const handleClickGuru=e=>{triggerHapticFeedback();if(energy<=0||isDisabled||isUpdatingRef.current){setGlowBooster(true);// Trigger glow effect if energy and points are 0\nsetTimeout(()=>{setGlowBooster(false);// Remove glow effect after 1 second\n},300);return;// Exit if no energy left or if clicks are disabled or if an update is in progress\n}const{offsetX,offsetY,target}=e.nativeEvent;const{clientWidth,clientHeight}=target;const horizontalMidpoint=clientWidth/2;const verticalMidpoint=clientHeight/2;const animationClass=offsetX<horizontalMidpoint?'wobble-left':offsetX>horizontalMidpoint?'wobble-right':offsetY<verticalMidpoint?'wobble-top':'wobble-bottom';// Remove previous animations\nimageRef.current.classList.remove('wobble-top','wobble-bottom','wobble-left','wobble-right');// Add the new animation class\nimageRef.current.classList.add(animationClass);// Remove the animation class after animation ends to allow re-animation on the same side\nsetTimeout(()=>{imageRef.current.classList.remove(animationClass);},500);// duration should match the animation duration in CSS\n// Increment the count\nconst rect=e.target.getBoundingClientRect();const newClick={id:Date.now(),// Unique identifier\nx:e.clientX-rect.left,y:e.clientY-rect.top};setClicks(prevClicks=>[...prevClicks,newClick]);// Update state immediately for UI\nsetEnergy(prevEnergy=>{const newEnergy=Math.max(prevEnergy-0,0);// Ensure energy does not drop below zero\naccumulatedEnergyRef.current=newEnergy;return newEnergy;});setPoints(prevPoints=>prevPoints+tapValue.value*5);setBalance(prevBalance=>{const newBalance=prevBalance+tapValue.value*5;accumulatedBalanceRef.current=newBalance;return newBalance;});setTapBalance(prevTapBalance=>{const newTapBalance=prevTapBalance+tapValue.value*5;accumulatedTapBalanceRef.current=newTapBalance;return newTapBalance;});// Remove the click after the animation duration\nsetTimeout(()=>{setClicks(prevClicks=>prevClicks.filter(click=>click.id!==newClick.id));},1000);// Match this duration with the animation duration\n// Reset the debounce timer\nclearTimeout(debounceTimerRef.current);debounceTimerRef.current=setTimeout(updateFirestore,1000);// Adjust the delay as needed\n// Reset the refill timer\nclearInterval(refillIntervalRef.current);// Stop refilling while the user is active\nsetIsRefilling(false);// Set refilling state to false\nclearTimeout(refillTimeoutRef.current);refillTimeoutRef.current=setTimeout(()=>{if(energy<battery.energy){refillEnergy();}},1000);// Set the inactivity period to 3 seconds (adjust as needed)\n};const updateFirestore=async()=>{var _window$Telegram$WebA;const telegramUser=(_window$Telegram$WebA=window.Telegram.WebApp.initDataUnsafe)===null||_window$Telegram$WebA===void 0?void 0:_window$Telegram$WebA.user;if(telegramUser){const{id:userId}=telegramUser;const userRef=doc(db,'telegramUsers',userId.toString());// Set updating flag\nisUpdatingRef.current=true;try{await updateDoc(userRef,{balance:accumulatedBalanceRef.current,energy:accumulatedEnergyRef.current,tapBalance:accumulatedTapBalanceRef.current});// No need to update state here as it is already updated immediately in handleClick\n// Reset accumulated values to current state values\naccumulatedBalanceRef.current=balance;accumulatedEnergyRef.current=energy;accumulatedTapBalanceRef.current=tapBalance;}catch(error){console.error('Error updating balance and energy:',error);}finally{// Clear updating flag\nisUpdatingRef.current=false;}}};const energyPercentage=energy/battery.energy*100;// const handleClaim = async () => {\n//   const telegramUser = window.Telegram.WebApp.initDataUnsafe?.user;\n//   if (telegramUser) {\n//     const { id: userId } = telegramUser;\n//     const userRef = doc(db, 'telegramUsers', userId.toString());\n//     try {\n//       await updateDoc(userRef, {\n//         balance: balance + points,\n//         energy: energy,\n//         tapBalance: tapBalance + points\n//       });\n//       setBalance((prevBalance) => prevBalance + points);\n//       setTapBalance((prevTapBalance) => prevTapBalance + points);\n//       localStorage.setItem('energy', energy);\n//       if (energy <= 0) {\n//         setIsTimerVisible(true);\n//       }\n//       console.log('Points claimed successfully');\n//     } catch (error) {\n//       console.error('Error updating balance and energy:', error);\n//     }\n//   }\n//   openClaimer();\n// };\nconst formatNumber=num=>{if(num<100000){return new Intl.NumberFormat().format(num).replace(/,/g,\" \");}else if(num<1000000){return new Intl.NumberFormat().format(num).replace(/,/g,\" \");}else{return(num/1000000).toFixed(3).replace(\".\",\".\")+\" M\";}};// // Remove the click after the animation duration\n// setTimeout(() => {\n//   setTapGuru(false);\n//   setMainTap(true);\n// }, 22000); // Match this duration with the animation duration\nreturn/*#__PURE__*/_jsx(_Fragment,{children:loading?/*#__PURE__*/_jsx(Spinner,{}):/*#__PURE__*/_jsx(Animate,{children:/*#__PURE__*/_jsxs(\"div\",{className:\"w-full flex justify-center flex-col overflow-hidden\",children:[/*#__PURE__*/_jsxs(\"div\",{className:\"flex space-x-[2px] justify-center items-center\",children:[/*#__PURE__*/_jsx(\"div\",{className:\"w-[50px] h-[50px]\",children:/*#__PURE__*/_jsx(\"img\",{src:coinsmall,className:\"w-full\",alt:\"coin\"})}),/*#__PURE__*/_jsxs(\"h1\",{className:\"text-[#fff] text-[42px] font-extrabold\",children:[formatNumber(balance+refBonus),\" \",/*#__PURE__*/_jsx(\"br\",{})]})]}),/*#__PURE__*/_jsxs(\"div\",{className:\"w-full ml-[6px] flex space-x-1 items-center justify-center\",children:[/*#__PURE__*/_jsx(\"img\",{src:level.imgUrl,className:\"w-[25px] relative\",alt:\"bronze\"}),/*#__PURE__*/_jsx(\"h2\",{onClick:()=>setShowLevels(true),className:\"text-[#9d99a9] text-[20px] font-medium\",children:level.name}),/*#__PURE__*/_jsx(MdOutlineKeyboardArrowRight,{className:\"w-[20px] h-[20px] text-[#9d99a9] mt-[2px]\"})]}),/*#__PURE__*/_jsxs(\"div\",{className:\"w-full flex justify-center items-center pt-7 pb-24 relative\",children:[/*#__PURE__*/_jsx(\"div\",{className:\"bg-[#efc26999] blur-[50px] absolute rotate-[35deg] w-[400px] h-[160px] top-10 -left-40 rounded-full\"}),/*#__PURE__*/_jsxs(\"div\",{class:\"\".concat(tapGuru?'block':'hidden',\" pyro\"),children:[/*#__PURE__*/_jsx(\"div\",{class:\"before\"}),/*#__PURE__*/_jsx(\"div\",{class:\"after\"})]}),/*#__PURE__*/_jsxs(\"div\",{className:\"w-[350px] h-[350px] relative flex items-center justify-center\",children:[/*#__PURE__*/_jsx(\"img\",{src:\"/lihgt.webp\",alt:\"err\",className:\"absolute w-[330px] rotate-45 \".concat(tapGuru?'block':'hidden')}),/*#__PURE__*/_jsxs(\"div\",{className:\"image-container\",children:[mainTap&&/*#__PURE__*/_jsxs(Container,{children:[/*#__PURE__*/_jsx(\"img\",{onPointerDown:handleClick,ref:imageRef,src:\"/tapme1.webp\",alt:\"Wobble\",className:\"wobble-image !w-[250px] select-none\"}),clicks.map(click=>/*#__PURE__*/_jsxs(SlideUpText,{x:click.x,y:click.y,children:[\"+\",tapValue.value]},click.id))]}),tapGuru&&/*#__PURE__*/_jsxs(Container,{children:[/*#__PURE__*/_jsx(\"img\",{onPointerDown:handleClickGuru,ref:imageRef,src:\"/tapme1.webp\",alt:\"Wobble\",className:\"wobble-image !w-[250px] select-none\"}),clicks.map(click=>/*#__PURE__*/_jsxs(SlideUpText,{x:click.x,y:click.y,children:[\"+\",tapValue.value*5]},click.id))]})]})]})]}),/*#__PURE__*/_jsx(\"div\",{className:\"flex flex-col space-y-6 fixed bottom-[120px] left-0 right-0 justify-center items-center px-5\",children:/*#__PURE__*/_jsxs(\"div\",{className:\"flex flex-col w-full items-center justify-center\",children:[/*#__PURE__*/_jsxs(\"div\",{className:\"flex pb-[6px] space-x-1 items-center justify-center text-[#fff]\",children:[/*#__PURE__*/_jsx(\"img\",{alt:\"flash\",src:flash,className:\"w-[20px]\"}),/*#__PURE__*/_jsxs(\"div\",{className:\"\",children:[/*#__PURE__*/_jsx(\"span\",{className:\"text-[18px] font-bold\",children:energy.toFixed(0)}),/*#__PURE__*/_jsxs(\"span\",{className:\"text-[14px] font-medium\",children:[\"/ \",battery.energy]})]})]}),/*#__PURE__*/_jsx(\"div\",{className:\"flex w-full p-[4px] h-[20px] items-center bg-energybar rounded-[12px] border-[1px] border-borders2\",children:/*#__PURE__*/_jsx(\"div\",{className:\"bg-[#e39725] h-full rounded-full transition-width duration-100\",style:{width:\"\".concat(energyPercentage,\"%\")}})})]})}),/*#__PURE__*/_jsx(Levels,{showLevels:showLevels,setShowLevels:setShowLevels})]})})});};export default Plutos;","map":null,"metadata":{},"sourceType":"module"}