{"ast":null,"code":"import { time } from '../../frameloop/sync-time.mjs';\nimport { DOMKeyframesResolver } from '../../render/dom/DOMKeyframesResolver.mjs';\nimport { memo } from '../../utils/memo.mjs';\nimport { noop } from '../../utils/noop.mjs';\nimport { millisecondsToSeconds, secondsToMilliseconds } from '../../utils/time-conversion.mjs';\nimport { BaseAnimation } from './BaseAnimation.mjs';\nimport { MainThreadAnimation } from './MainThreadAnimation.mjs';\nimport { animateStyle } from './waapi/index.mjs';\nimport { isWaapiSupportedEasing } from './waapi/easing.mjs';\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\nconst supportsWaapi = memo(() => Object.hasOwnProperty.call(Element.prototype, \"animate\"));\n/**\n * A list of values that can be hardware-accelerated.\n */\n\nconst acceleratedValues = new Set([\"opacity\", \"clipPath\", \"filter\", \"transform\" // TODO: Can be accelerated but currently disabled until https://issues.chromium.org/issues/41491098 is resolved\n// or until we implement support for linear() easing.\n// \"background-color\"\n]);\n/**\n * 10ms is chosen here as it strikes a balance between smooth\n * results (more than one keyframe per frame at 60fps) and\n * keyframe quantity.\n */\n\nconst sampleDelta = 10; //ms\n\n/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\n\nconst maxDuration = 20000;\n/**\n * Check if an animation can run natively via WAAPI or requires pregenerated keyframes.\n * WAAPI doesn't support spring or function easings so we run these as JS animation before\n * handing off.\n */\n\nfunction requiresPregeneratedKeyframes(options) {\n  return options.type === \"spring\" || options.name === \"backgroundColor\" || !isWaapiSupportedEasing(options.ease);\n}\n\nfunction pregenerateKeyframes(keyframes, options) {\n  /**\n   * Create a main-thread animation to pregenerate keyframes.\n   * We sample this at regular intervals to generate keyframes that we then\n   * linearly interpolate between.\n   */\n  const sampleAnimation = new MainThreadAnimation({ ...options,\n    keyframes,\n    repeat: 0,\n    delay: 0,\n    isGenerator: true\n  });\n  let state = {\n    done: false,\n    value: keyframes[0]\n  };\n  const pregeneratedKeyframes = [];\n  /**\n   * Bail after 20 seconds of pre-generated keyframes as it's likely\n   * we're heading for an infinite loop.\n   */\n\n  let t = 0;\n\n  while (!state.done && t < maxDuration) {\n    state = sampleAnimation.sample(t);\n    pregeneratedKeyframes.push(state.value);\n    t += sampleDelta;\n  }\n\n  return {\n    times: undefined,\n    keyframes: pregeneratedKeyframes,\n    duration: t - sampleDelta,\n    ease: \"linear\"\n  };\n}\n\nclass AcceleratedAnimation extends BaseAnimation {\n  constructor(options) {\n    super(options);\n    const {\n      name,\n      motionValue,\n      keyframes\n    } = this.options;\n    this.resolver = new DOMKeyframesResolver(keyframes, (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe), name, motionValue);\n    this.resolver.scheduleResolve();\n  }\n\n  initPlayback(keyframes, finalKeyframe) {\n    var _a;\n\n    let {\n      duration = 300,\n      times,\n      ease,\n      type,\n      motionValue,\n      name\n    } = this.options;\n    /**\n     * If element has since been unmounted, return false to indicate\n     * the animation failed to initialised.\n     */\n\n    if (!((_a = motionValue.owner) === null || _a === void 0 ? void 0 : _a.current)) {\n      return false;\n    }\n    /**\n     * If this animation needs pre-generated keyframes then generate.\n     */\n\n\n    if (requiresPregeneratedKeyframes(this.options)) {\n      const {\n        onComplete,\n        onUpdate,\n        motionValue,\n        ...options\n      } = this.options;\n      const pregeneratedAnimation = pregenerateKeyframes(keyframes, options);\n      keyframes = pregeneratedAnimation.keyframes; // If this is a very short animation, ensure we have\n      // at least two keyframes to animate between as older browsers\n      // can't animate between a single keyframe.\n\n      if (keyframes.length === 1) {\n        keyframes[1] = keyframes[0];\n      }\n\n      duration = pregeneratedAnimation.duration;\n      times = pregeneratedAnimation.times;\n      ease = pregeneratedAnimation.ease;\n      type = \"keyframes\";\n    }\n\n    const animation = animateStyle(motionValue.owner.current, name, keyframes, { ...this.options,\n      duration,\n      times,\n      ease\n    }); // Override the browser calculated startTime with one synchronised to other JS\n    // and WAAPI animations starting this event loop.\n\n    animation.startTime = time.now();\n\n    if (this.pendingTimeline) {\n      animation.timeline = this.pendingTimeline;\n      this.pendingTimeline = undefined;\n    } else {\n      /**\n       * Prefer the `onfinish` prop as it's more widely supported than\n       * the `finished` promise.\n       *\n       * Here, we synchronously set the provided MotionValue to the end\n       * keyframe. If we didn't, when the WAAPI animation is finished it would\n       * be removed from the element which would then revert to its old styles.\n       */\n      animation.onfinish = () => {\n        const {\n          onComplete\n        } = this.options;\n        motionValue.set(getFinalKeyframe(keyframes, this.options, finalKeyframe));\n        onComplete && onComplete();\n        this.cancel();\n        this.resolveFinishedPromise();\n      };\n    }\n\n    return {\n      animation,\n      duration,\n      times,\n      type,\n      ease,\n      keyframes: keyframes\n    };\n  }\n\n  get duration() {\n    const {\n      resolved\n    } = this;\n    if (!resolved) return 0;\n    const {\n      duration\n    } = resolved;\n    return millisecondsToSeconds(duration);\n  }\n\n  get time() {\n    const {\n      resolved\n    } = this;\n    if (!resolved) return 0;\n    const {\n      animation\n    } = resolved;\n    return millisecondsToSeconds(animation.currentTime || 0);\n  }\n\n  set time(newTime) {\n    const {\n      resolved\n    } = this;\n    if (!resolved) return;\n    const {\n      animation\n    } = resolved;\n    animation.currentTime = secondsToMilliseconds(newTime);\n  }\n\n  get speed() {\n    const {\n      resolved\n    } = this;\n    if (!resolved) return 1;\n    const {\n      animation\n    } = resolved;\n    return animation.playbackRate;\n  }\n\n  set speed(newSpeed) {\n    const {\n      resolved\n    } = this;\n    if (!resolved) return;\n    const {\n      animation\n    } = resolved;\n    animation.playbackRate = newSpeed;\n  }\n\n  get state() {\n    const {\n      resolved\n    } = this;\n    if (!resolved) return \"idle\";\n    const {\n      animation\n    } = resolved;\n    return animation.playState;\n  }\n  /**\n   * Replace the default DocumentTimeline with another AnimationTimeline.\n   * Currently used for scroll animations.\n   */\n\n\n  attachTimeline(timeline) {\n    if (!this._resolved) {\n      this.pendingTimeline = timeline;\n    } else {\n      const {\n        resolved\n      } = this;\n      if (!resolved) return noop;\n      const {\n        animation\n      } = resolved;\n      animation.timeline = timeline;\n      animation.onfinish = null;\n    }\n\n    return noop;\n  }\n\n  play() {\n    if (this.isStopped) return;\n    const {\n      resolved\n    } = this;\n    if (!resolved) return;\n    const {\n      animation\n    } = resolved;\n\n    if (animation.playState === \"finished\") {\n      this.updateFinishedPromise();\n    }\n\n    animation.play();\n  }\n\n  pause() {\n    const {\n      resolved\n    } = this;\n    if (!resolved) return;\n    const {\n      animation\n    } = resolved;\n    animation.pause();\n  }\n\n  stop() {\n    this.resolver.cancel();\n    this.isStopped = true;\n    if (this.state === \"idle\") return;\n    const {\n      resolved\n    } = this;\n    if (!resolved) return;\n    const {\n      animation,\n      keyframes,\n      duration,\n      type,\n      ease,\n      times\n    } = resolved;\n\n    if (animation.playState === \"idle\" || animation.playState === \"finished\") {\n      return;\n    }\n    /**\n     * WAAPI doesn't natively have any interruption capabilities.\n     *\n     * Rather than read commited styles back out of the DOM, we can\n     * create a renderless JS animation and sample it twice to calculate\n     * its current value, \"previous\" value, and therefore allow\n     * Motion to calculate velocity for any subsequent animation.\n     */\n\n\n    if (this.time) {\n      const {\n        motionValue,\n        onUpdate,\n        onComplete,\n        ...options\n      } = this.options;\n      const sampleAnimation = new MainThreadAnimation({ ...options,\n        keyframes,\n        duration,\n        type,\n        ease,\n        times,\n        isGenerator: true\n      });\n      const sampleTime = secondsToMilliseconds(this.time);\n      motionValue.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);\n    }\n\n    this.cancel();\n  }\n\n  complete() {\n    const {\n      resolved\n    } = this;\n    if (!resolved) return;\n    resolved.animation.finish();\n  }\n\n  cancel() {\n    const {\n      resolved\n    } = this;\n    if (!resolved) return;\n    resolved.animation.cancel();\n  }\n\n  static supports(options) {\n    const {\n      motionValue,\n      name,\n      repeatDelay,\n      repeatType,\n      damping,\n      type\n    } = options;\n    return supportsWaapi() && name && acceleratedValues.has(name) && motionValue && motionValue.owner && motionValue.owner.current instanceof HTMLElement &&\n    /**\n     * If we're outputting values to onUpdate then we can't use WAAPI as there's\n     * no way to read the value from WAAPI every frame.\n     */\n    !motionValue.owner.getProps().onUpdate && !repeatDelay && repeatType !== \"mirror\" && damping !== 0 && type !== \"inertia\";\n  }\n\n}\n\nexport { AcceleratedAnimation };","map":null,"metadata":{},"sourceType":"module"}